/**
 * n.Solve - UAN (Universal Adapter Network) Agent
 * Cria adaptadores automaticamente usando IA para ferramentas não suportadas
 */

export interface Env {
  AI: any;
  VLM_DB: D1Database;
  VLM_STORAGE: R2Bucket;
}

interface FieldMapping {
  input: string;
  output_cdm: string;
  normalizacao?: string;
  transformacao?: string;
}

interface AdapterMapping {
  nome_parser: string;
  tool_name: string;
  mapa_campos: FieldMapping[];
  severity_mapping?: Record<string, string>;
  requires_translation?: boolean;
}

/**
 * Inferir estrutura do JSON usando Workers AI
 */
async function inferStructure(sampleJson: any, env: Env): Promise<AdapterMapping> {
  try {
    const prompt = `You are the Universal Adapter Agent for n.Solve vulnerability management system.

Analyze this sample vulnerability report JSON and map it to our Canonical Data Model (CDM).

**Sample JSON:**
${JSON.stringify(sampleJson, null, 2)}

**Target CDM Fields:**
- titulo (string): Vulnerability title/name
- severidade_ajustada (CRITICAL|HIGH|MEDIUM|LOW): Severity level
- descricao (string): Description
- cwe (string): CWE identifier
- cvss_score (number): CVSS score
- location_detail (string): URL or file path
- parameter (string): Affected parameter
- evidence (string): Proof of concept

**Your Task:**
1. Identify which field in the input JSON corresponds to each CDM field
2. Suggest normalization rules (e.g., map "Alto" → "HIGH", "5" → "CRITICAL")
3. Detect if translation is needed (Portuguese/Spanish → English)
4. Suggest a parser name based on the tool

**Return ONLY valid JSON in this exact format:**
{
  "nome_parser": "suggested-tool-name",
  "tool_name": "Tool Name",
  "mapa_campos": [
    {
      "input": "field_name_in_input",
      "output_cdm": "titulo",
      "transformacao": "optional transformation logic"
    }
  ],
  "severity_mapping": {
    "input_value": "CDM_VALUE"
  },
  "requires_translation": false
}`;

    const response = await env.AI.run('@cf/meta/llama-2-7b-chat-int8', {
      messages: [
        {
          role: 'system',
          content: 'You are a JSON structure analyzer. Return ONLY valid JSON, no explanations.'
        },
        {
          role: 'user',
          content: prompt
        }
      ]
    });

    // Parse AI response
    const aiResponse = response.response || '{}';
    
    // Extract JSON from response (AI might add text)
    const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      return JSON.parse(jsonMatch[0]);
    }

    // Fallback: simple heuristic mapping
    return inferStructureHeuristic(sampleJson);

  } catch (error) {
    console.error('AI inference error:', error);
    return inferStructureHeuristic(sampleJson);
  }
}

/**
 * Fallback heuristic inference
 */
function inferStructureHeuristic(sampleJson: any): AdapterMapping {
  const mapping: AdapterMapping = {
    nome_parser: 'custom-tool',
    tool_name: 'Custom Tool',
    mapa_campos: [],
    severity_mapping: {},
    requires_translation: false
  };

  const sample = Array.isArray(sampleJson) ? sampleJson[0] : sampleJson;
  
  // Heuristics for common field names
  const fieldHeuristics: Record<string, string[]> = {
    titulo: ['name', 'title', 'vulnerability', 'finding', 'issue', 'alert'],
    severidade_ajustada: ['severity', 'risk', 'priority', 'level', 'criticality'],
    descricao: ['description', 'desc', 'details', 'summary'],
    cwe: ['cwe', 'cweid', 'weakness'],
    cvss_score: ['cvss', 'score', 'cvss_score'],
    location_detail: ['url', 'path', 'location', 'file', 'target'],
    parameter: ['param', 'parameter', 'field', 'input'],
  };

  for (const [cdmField, possibleNames] of Object.entries(fieldHeuristics)) {
    for (const key of Object.keys(sample)) {
      const keyLower = key.toLowerCase();
      if (possibleNames.some(name => keyLower.includes(name))) {
        mapping.mapa_campos.push({
          input: key,
          output_cdm: cdmField
        });
        break;
      }
    }
  }

  return mapping;
}

/**
 * Generate Adapter Code
 */
function generateAdapterCode(mapping: AdapterMapping): string {
  const code = `/**
 * Auto-generated Adapter for ${mapping.tool_name}
 * Generated by n.Solve UAN Agent
 */

export interface ${mapping.nome_parser.replace(/-/g, '_')}_Finding {
${mapping.mapa_campos.map(m => `  ${m.input}: any;`).join('\n')}
}

/**
 * Normalize severity
 */
function normalizeSeverity(value: any): string {
  const mapping: Record<string, string> = ${JSON.stringify(mapping.severity_mapping || {}, null, 2)};
  
  const strValue = String(value).toLowerCase();
  if (mapping[strValue]) {
    return mapping[strValue];
  }
  
  // Fallback heuristics
  if (strValue.includes('critical') || strValue.includes('5')) return 'CRITICAL';
  if (strValue.includes('high') || strValue.includes('alto') || strValue.includes('4')) return 'HIGH';
  if (strValue.includes('medium') || strValue.includes('medio') || strValue.includes('3')) return 'MEDIUM';
  if (strValue.includes('low') || strValue.includes('baixo') || strValue.includes('1') || strValue.includes('2')) return 'LOW';
  
  return 'MEDIUM';
}

/**
 * Handle ${mapping.tool_name} Payload
 */
export async function handle${mapping.nome_parser.replace(/-/g, '_')}_Payload(payload: any, env: any): Promise<any> {
  try {
    const findings = Array.isArray(payload) ? payload : (payload.findings || payload.vulnerabilities || [payload]);
    const results = {
      processed: 0,
      duplicates: 0,
      errors: 0,
      created: [] as string[],
    };

    for (const finding of findings) {
      try {
        // Extract fields based on mapping
        const titulo = finding.${mapping.mapa_campos.find(m => m.output_cdm === 'titulo')?.input || 'name'};
        const severidadeRaw = finding.${mapping.mapa_campos.find(m => m.output_cdm === 'severidade_ajustada')?.input || 'severity'};
        const descricao = finding.${mapping.mapa_campos.find(m => m.output_cdm === 'descricao')?.input || 'description'};
        
        const severidade = normalizeSeverity(severidadeRaw);

        // Generate correlation key
        const correlationKey = await generateCorrelationKey(titulo, descricao);

        // Check for duplicates
        const existing = await env.VLM_DB
          .prepare('SELECT id FROM vulnerabilities WHERE correlation_key = ?')
          .bind(correlationKey)
          .first();

        if (existing) {
          results.duplicates++;
          continue;
        }

        // Insert into D1
        const vulnId = \`vuln-\${crypto.randomUUID()}\`;
        await env.VLM_DB.prepare(\`
          INSERT INTO vulnerabilities (
            id, title, description, severity, status, status_vlm,
            tenant_id, source_tool, correlation_key, created_at, updated_at
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
        \`).bind(
          vulnId,
          titulo,
          descricao,
          severidade,
          'open',
          'PENDING_TRIAGE',
          'org-ness',
          '${mapping.tool_name}',
          correlationKey
        ).run();

        results.processed++;
        results.created.push(vulnId);

      } catch (error) {
        console.error('Error processing finding:', error);
        results.errors++;
      }
    }

    return {
      success: true,
      message: \`Processed \${results.processed} findings from ${mapping.tool_name}\`,
      stats: results
    };

  } catch (error) {
    console.error('${mapping.tool_name} Adapter Error:', error);
    return {
      success: false,
      error: 'Failed to process payload'
    };
  }
}

async function generateCorrelationKey(title: string, description: string): Promise<string> {
  const data = \`\${title}|\${description}\`.toLowerCase();
  const buffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(data));
  return Array.from(new Uint8Array(buffer)).map(b => b.toString(16).padStart(2, '0')).join('');
}
`;

  return code;
}

/**
 * Main Worker Handler
 */
export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);

    const corsHeaders = {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    };

    if (request.method === 'OPTIONS') {
      return new Response(null, { headers: corsHeaders });
    }

    try {
      // POST /infer - Infer structure from sample JSON
      if (url.pathname === '/infer' && request.method === 'POST') {
        const body = await request.json() as any;
        const { sample_json, tool_name } = body;

        if (!sample_json) {
          return new Response(JSON.stringify({ error: 'sample_json is required' }), {
            status: 400,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }

        // Infer structure using AI
        const mapping = await inferStructure(sample_json, env);
        
        // Override tool_name if provided
        if (tool_name) {
          mapping.tool_name = tool_name;
          mapping.nome_parser = tool_name.toLowerCase().replace(/\s+/g, '-');
        }

        // Save mapping to D1
        await env.VLM_DB.prepare(`
          INSERT INTO adapter_mappings (
            id, tool_name, nome_parser, mapping_json, created_at
          ) VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)
        `).bind(
          `adapter-${crypto.randomUUID()}`,
          mapping.tool_name,
          mapping.nome_parser,
          JSON.stringify(mapping)
        ).run();

        return new Response(JSON.stringify({
          success: true,
          data: mapping
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }

      // POST /generate-adapter - Generate adapter code
      if (url.pathname === '/generate-adapter' && request.method === 'POST') {
        const body = await request.json() as any;
        const { mapping } = body;

        if (!mapping) {
          return new Response(JSON.stringify({ error: 'mapping is required' }), {
            status: 400,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }

        // Generate TypeScript adapter code
        const code = generateAdapterCode(mapping);

        // Save to R2
        const filename = `adapters/${mapping.nome_parser}-adapter.ts`;
        await env.VLM_STORAGE.put(filename, code, {
          httpMetadata: {
            contentType: 'text/plain',
          },
        });

        return new Response(JSON.stringify({
          success: true,
          data: {
            code,
            filename,
            download_url: `https://storage.ness.tec.br/${filename}`
          }
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }

      // GET /adapters - List all adapter mappings
      if (url.pathname === '/adapters' && request.method === 'GET') {
        const result = await env.VLM_DB.prepare(`
          SELECT * FROM adapter_mappings ORDER BY created_at DESC
        `).all();

        return new Response(JSON.stringify({
          success: true,
          count: result.results?.length || 0,
          data: result.results
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }

      // Health check
      if (url.pathname === '/health') {
        return new Response(JSON.stringify({
          status: 'healthy',
          worker: 'uan-agent',
          ai_available: !!env.AI,
          timestamp: new Date().toISOString()
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }

      return new Response(JSON.stringify({ error: 'Not Found' }), {
        status: 404,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });

    } catch (error) {
      console.error('UAN Agent Error:', error);
      return new Response(JSON.stringify({ error: 'Internal Server Error' }), {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }
  },
};

