/**
 * Pentest Tools Adapter
 * Traduz payload do pentest-tools.com para CDM do n.Solve
 * Usa lógica refinada de persistência (Reimportação vs Deduplicação)
 */

import { Env } from '../index';

/**
 * Process Finding for Persistence (inline com Políticas Configuráveis)
 */
async function processFindingForPersistence(
  finding: any, 
  assetId: string, 
  tenantId: string,
  assetConfig: any, 
  env: Env
): Promise<any> {
  const correlationKey = finding.correlation_key;
  const currentTimestamp = new Date().toISOString();

  // LÓGICA DE DESATIVAÇÃO: Se deduplicação está desabilitada, sempre criar novo achado
  if (!assetConfig.enable_deduplication) {
    const newId = `vuln-${crypto.randomUUID()}`;

    await env.VLM_DB.prepare(`
      INSERT INTO vulnerabilities (
        id, title, description, severity, status, status_vlm,
        correlation_key, is_duplicate, asset_id, tenant_id, source_tool,
        cve, cvss_score, first_seen_timestamp, last_seen_timestamp,
        created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, 'PENDING_TRIAGE', ?, FALSE, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
    `).bind(
      newId, finding.title, finding.description, finding.severity,
      'open', correlationKey, assetId, tenantId, finding.source_tool,
      finding.cve, finding.cvss_score, currentTimestamp, currentTimestamp
    ).run();

    return {
      status: 'NEW_FINDING',
      finding_uuid: newId,
      deduplication_bypassed: true
    };
  }

  // LÓGICA DE ESCOPO DE BUSCA: Ajustar query SQL baseado no escopo
  let scopeCondition = '';
  let scopeBindings: any[] = [correlationKey];

  if (assetConfig.deduplication_scope === 'ASSET') {
    scopeCondition = 'AND asset_id = ?';
    scopeBindings.push(assetId);
  } else if (assetConfig.deduplication_scope === 'TENANT') {
    scopeCondition = 'AND tenant_id = ?';
    scopeBindings.push(tenantId);
  }

  // Buscar achado original com escopo configurável
  const originalFinding = await env.VLM_DB
    .prepare(`SELECT * FROM vulnerabilities WHERE correlation_key = ? ${scopeCondition} AND is_duplicate = FALSE LIMIT 1`)
    .bind(...scopeBindings)
    .first();

  if (originalFinding) {
    const original = originalFinding as any;

    // REIMPORTAÇÃO (mesmo asset)
    if (original.asset_id === assetId) {
      await env.VLM_DB.prepare(`
        UPDATE vulnerabilities 
        SET last_seen_timestamp = ?, updated_at = CURRENT_TIMESTAMP
        WHERE id = ?
      `).bind(currentTimestamp, original.id).run();

      return {
        status: 'REIMPORTED_FILTERED',
        finding_uuid: original.id,
        original_finding_uuid: original.id
      };
    }

    // DEDUPLICAÇÃO (asset diferente dentro do escopo)
    else {
      const duplicateId = `vuln-${crypto.randomUUID()}`;

      await env.VLM_DB.prepare(`
        INSERT INTO vulnerabilities (
          id, title, description, severity, status, status_vlm,
          correlation_key, original_finding_uuid, is_duplicate,
          asset_id, tenant_id, source_tool,
          first_seen_timestamp, last_seen_timestamp,
          created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, 'INACTIVE_DUPLICATE', ?, ?, TRUE, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
      `).bind(
        duplicateId, finding.title, finding.description, finding.severity,
        'open', correlationKey, original.id,
        assetId, tenantId, finding.source_tool,
        currentTimestamp, currentTimestamp
      ).run();

      return {
        status: 'DUPLICATE_CREATED',
        finding_uuid: duplicateId,
        original_finding_uuid: original.id
      };
    }
  }

  // NOVO ACHADO (sem correlação encontrada)
  const newId = `vuln-${crypto.randomUUID()}`;

  await env.VLM_DB.prepare(`
    INSERT INTO vulnerabilities (
      id, title, description, severity, status, status_vlm,
      correlation_key, is_duplicate, asset_id, tenant_id, source_tool,
      cve, cvss_score, first_seen_timestamp, last_seen_timestamp,
      created_at, updated_at
    ) VALUES (?, ?, ?, ?, ?, 'PENDING_TRIAGE', ?, FALSE, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
  `).bind(
    newId, finding.title, finding.description, finding.severity,
    'open', correlationKey, assetId, tenantId, finding.source_tool,
    finding.cve, finding.cvss_score, currentTimestamp, currentTimestamp
  ).run();

  return {
    status: 'NEW_FINDING',
    finding_uuid: newId
  };
}

export interface PentestToolFinding {
  id: string;
  name: string;
  cwe?: string;
  cvss?: number;
  vuln_evidence?: string;
  risk_level: string;
  url: string;
  parameter?: string;
  description?: string;
  recommendation?: string;
}

/**
 * Generate correlation key
 */
async function generateCorrelationKey(type: string, url: string, param: string): Promise<string> {
  const data = `${type}|${url}|${param}`.toLowerCase();
  const buffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(data));
  return Array.from(new Uint8Array(buffer)).map(b => b.toString(16).padStart(2, '0')).join('');
}

/**
 * Normalize severity
 */
function normalizeSeverity(riskLevel: string): string {
  const level = riskLevel.toLowerCase();
  switch (level) {
    case 'critical':
    case 'very high':
      return 'CRITICAL';
    case 'high':
      return 'HIGH';
    case 'medium':
    case 'moderate':
      return 'MEDIUM';
    case 'low':
      return 'LOW';
    default:
      return 'MEDIUM';
  }
}

/**
 * Handle Pentest Tools Payload
 */
export async function handlePentestToolsPayload(payload: any, env: Env): Promise<any> {
  try {
    const findings: PentestToolFinding[] = payload.findings || payload.vulnerabilities || [payload];
    const assetId = payload.asset_id || 'asset-pentest-tools';
    const tenantId = payload.tenant_id || 'tenant_ness';
    
    const results = {
      new_findings: 0,
      reimported: 0,
      duplicates_created: 0,
      closed_findings: 0,
      reactivated_findings: 0,
      errors: 0,
      details: [] as any[],
    };

    // Buscar AssetConfig para obter políticas
    let assetConfig: any = null;
    try {
      assetConfig = await env.VLM_DB
        .prepare('SELECT * FROM asset_configs WHERE id = ? AND tenant_id = ? LIMIT 1')
        .bind(assetId, tenantId)
        .first();
    } catch (error) {
      console.warn(`[PentestTools] AssetConfig not found for ${assetId}, using defaults`);
    }

    // Defaults se não houver configuração
    if (!assetConfig) {
      assetConfig = {
        enable_deduplication: true,
        deduplication_scope: 'TENANT',
        delete_duplicate_findings: false,
        max_duplicates: 10,
        reimport_enabled: false,
        close_old_findings: false,
        do_not_reactivate: false,
      };
    }

    // STEP 1: REIMPORT - Processar fechamento/reabertura se habilitado
    let findingsToProcess = findings;
    
    if (assetConfig.reimport_enabled) {
      console.log(`[PentestTools] Reimport enabled, processing ${findings.length} findings for asset ${assetId}`);
      
      // Converter findings para NSolveFinding com correlation_key
      const nsolveFindings: any[] = [];
      for (const finding of findings) {
        const correlationKey = await generateCorrelationKey(
          finding.name || 'unknown',
          finding.url || '',
          finding.parameter || ''
        );
        
        nsolveFindings.push({
          correlation_key: correlationKey,
          title: finding.name || 'Unknown Vulnerability',
          source_tool: 'pentest-tools',
          // ... outros campos serão processados depois
          _rawFinding: finding, // Manter referência ao finding original
        });
      }

      // Executar lógica de reimport (inline simplificada)
      const currentCorrelationKeys = new Set(nsolveFindings.map(f => f.correlation_key));

      // Buscar achados ativos existentes
      const existingActive = await env.VLM_DB
        .prepare(`
          SELECT id, correlation_key, status_vlm
          FROM vulnerabilities
          WHERE asset_id = ? AND source_tool = ?
            AND status_vlm IN ('ACTIVE', 'ACTIVE_VERIFIED', 'UNDER_REVIEW')
            AND is_duplicate = FALSE
        `)
        .bind(assetId, 'pentest-tools')
        .all();

      // FECHAR achados não encontrados no scan atual
      if (assetConfig.close_old_findings) {
        for (const existing of (existingActive.results || []) as any[]) {
          if (!currentCorrelationKeys.has(existing.correlation_key)) {
            await env.VLM_DB
              .prepare(`
                UPDATE vulnerabilities 
                SET status_vlm = 'INACTIVE_MITIGATED', 
                    mitigated_date = CURRENT_TIMESTAMP, 
                    updated_at = CURRENT_TIMESTAMP,
                    last_status_change_date = CURRENT_TIMESTAMP
                WHERE id = ?
              `)
              .bind(existing.id)
              .run();
            
            results.closed_findings++;
            console.log(`[PentestTools] INACTIVE_MITIGATED finding ${existing.id}`);
          }
        }
      }

      // REABRIR achados fechados encontrados no scan atual
      if (!assetConfig.do_not_reactivate) {
        const closedFindings = await env.VLM_DB
          .prepare(`
            SELECT id, correlation_key, status_vlm
            FROM vulnerabilities
            WHERE asset_id = ? AND source_tool = ?
              AND status_vlm IN ('INACTIVE_MITIGATED', 'INACTIVE_RISK_ACCEPTED', 'INACTIVE_OUT_OF_SCOPE')
              AND is_duplicate = FALSE
          `)
          .bind(assetId, 'pentest-tools')
          .all();

        for (const closed of (closedFindings.results || []) as any[]) {
          // BLOQUEIO DE FP: Nunca reativar INACTIVE_FALSE_POSITIVE
          if (closed.status_vlm === 'INACTIVE_FALSE_POSITIVE') {
            console.log(`[PentestTools] BLOCKED reactivation of FP finding ${closed.id}`);
            continue;
          }
          
          if (currentCorrelationKeys.has(closed.correlation_key)) {
            await env.VLM_DB
              .prepare(`
                UPDATE vulnerabilities 
                SET status_vlm = 'ACTIVE', 
                    mitigated_date = NULL, 
                    updated_at = CURRENT_TIMESTAMP, 
                    last_seen_timestamp = CURRENT_TIMESTAMP,
                    last_status_change_date = CURRENT_TIMESTAMP
                WHERE id = ?
              `)
              .bind(closed.id)
              .run();
            
            results.reactivated_findings++;
            console.log(`[PentestTools] REACTIVATED finding ${closed.id} (${closed.status_vlm} → ACTIVE)`);
            
            // Remover do conjunto para não criar duplicado
            currentCorrelationKeys.delete(closed.correlation_key);
          }
        }
      }

      // Filtrar apenas achados NOVOS para processar
      const existingCorrelationKeys = new Set(
        (existingActive.results || []).map((f: any) => f.correlation_key)
      );

      findingsToProcess = findings.filter((_, idx) => {
        const correlationKey = nsolveFindings[idx].correlation_key;
        return !existingCorrelationKeys.has(correlationKey) && currentCorrelationKeys.has(correlationKey);
      });

      console.log(`[PentestTools] After reimport: ${findingsToProcess.length} findings to process (closed: ${results.closed_findings}, reactivated: ${results.reactivated_findings})`);
    }

    // STEP 2: DEDUPLICATION - Processar apenas achados novos/filtrados
    for (const finding of findingsToProcess) {
      try {
        // Generate correlation key
        const correlationKey = await generateCorrelationKey(
          finding.name || 'unknown',
          finding.url || '',
          finding.parameter || ''
        );

        // Normalize severity
        const severity = normalizeSeverity(finding.risk_level || 'medium');

        // Build NSolveFinding for persistence
        const nsolveFinding = {
          correlation_key: correlationKey,
          titulo: finding.name || 'Unknown Vulnerability',
          title: finding.name || 'Unknown Vulnerability',
          description: `${finding.description || ''}\n\n**Evidence:**\n${finding.vuln_evidence || 'N/A'}\n\n**Recommendation:**\n${finding.recommendation || 'N/A'}`,
          severidade_original: severity,
          severidade_ajustada: severity,
          severity: severity,
          cve: finding.cwe ? `CWE-${finding.cwe}` : undefined,
          cvss_score: finding.cvss,
          cwe: finding.cwe,
          source_tool: 'pentest-tools',
          location_type: 'WEB',
          tenant_id: tenantId,
          control_mapping: [],
        };

        // Use refined persistence logic with AssetConfig
        const persistenceResult = await processFindingForPersistence(
          nsolveFinding,
          assetId,
          tenantId,
          assetConfig,
          env
        );

        // Track results
        switch (persistenceResult.status) {
          case 'NEW_FINDING':
            results.new_findings++;
            break;
          case 'REIMPORTED_FILTERED':
            results.reimported++;
            break;
          case 'DUPLICATE_CREATED':
            results.duplicates_created++;
            break;
        }

        results.details.push({
          finding_id: finding.id,
          persistence_status: persistenceResult.status,
          uuid: persistenceResult.finding_uuid,
          original_uuid: persistenceResult.original_finding_uuid
        });

      } catch (error) {
        console.error('Error processing finding:', error);
        results.errors++;
      }
    }

    return {
      success: true,
      message: `Processed ${results.new_findings + results.reimported + results.duplicates_created} findings from Pentest Tools`,
      stats: {
        new_findings: results.new_findings,
        reimported_filtered: results.reimported,
        duplicates_created: results.duplicates_created,
        errors: results.errors,
        total: findings.length
      },
      details: results.details
    };

  } catch (error) {
    console.error('Pentest Tools Adapter Error:', error);
    return {
      success: false,
      error: 'Failed to process payload'
    };
  }
}
